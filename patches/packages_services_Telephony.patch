From c17a712c73fc538ef4f180badf190303dc66dc6f Mon Sep 17 00:00:00 2001
From: Preeti Ahuja <preetia@codeaurora.org>
Date: Thu, 21 Aug 2014 16:35:34 -0700
Subject: [PATCH 1/3] SEEK: Following changes have been made for SEEK

1. Support getAtr api.
   Implement getAtr for SEEK on Android.

2. Send correct response for iccTransmitApduLogicalChannel,
   iccTransmitApduBasicChannel & iccExchangeSimIO requests.

   When these requests fail, PhoneInterfaceManager sets its
   response to a default value ( IccIoResult with sw1 = 0x6f,
   sw2 = 0  and payload as null).

   Do not modify the response of the requests; Send the
   response received from RIL to the client.

3. Add Multi sim support.

   Msim support for following apis has been added:
   1. iccOpenLogicalChannel
   2. iccCloseLogicalChannel
   3. iccTransmitApduLogicalChannel
   4. iccTransmitApduBasicChannel
   5. iccExchangeSimIO
   6. getATR

CRs-Fixed: 718469

4. SEEK: Send correct responses for apdu transmit and simIO requests.

Correct the responses sent for IccTransmitApduLogicalChannel,
iccTransmitApduBasicChannel & iccExchangeSimIO requests:

When these requests fail with some response data from RIL,
send the response received from RIL to client.

But when the requests fail without any response data from RIL,
set the response to a default value ( IccIoResult with sw1 = 0x6f,
sw2 = 0  and payload as null). Without this, the response for the client
is set to null and PhoneInterfaceManager enters an infinite loop while
processing the response.

CRs-Fixed: 829284
Change-Id: I9494e17395a834b9a7c997c1afb5ef4b31b28e76

5. Msim SEEK: Make sure the apis use the subId correctly.

Retireve the uicc card object and check for enforced permissions based
on the subId provided by the client in the apis.

Change-Id: Idedb0a62a950e923a7a3fde5d07492f0c7a125a3
CRs-Fixed: 840826

Change-Id: I794e614e324c414b08c78fbdd601414b52b98b77

Signed-off-by: Dominggoes Isakh <drjisakh@gmail.com>
---
 src/com/android/phone/PhoneInterfaceManager.java | 174 +++++++++++++++++++----
 1 file changed, 150 insertions(+), 24 deletions(-)

diff --git a/src/com/android/phone/PhoneInterfaceManager.java b/src/com/android/phone/PhoneInterfaceManager.java
index 21b3b22..f7814c2 100644
--- a/src/com/android/phone/PhoneInterfaceManager.java
+++ b/src/com/android/phone/PhoneInterfaceManager.java
@@ -138,6 +138,8 @@ public class PhoneInterfaceManager extends ITelephony.Stub {
     private static final int EVENT_PERFORM_NETWORK_SCAN_DONE = 40;
     private static final int CMD_SET_NETWORK_SELECTION_MODE_MANUAL = 41;
     private static final int EVENT_SET_NETWORK_SELECTION_MODE_MANUAL_DONE = 42;
+    private static final int CMD_SIM_GET_ATR = 43;
+    private static final int EVENT_SIM_GET_ATR_DONE = 44;
 
     /** The singleton instance. */
     private static PhoneInterfaceManager sInstance;
@@ -317,6 +319,7 @@ public class PhoneInterfaceManager extends ITelephony.Stub {
                 case CMD_TRANSMIT_APDU_LOGICAL_CHANNEL:
                     request = (MainThreadRequest) msg.obj;
                     iccArgument = (IccAPDUArgument) request.argument;
+                    uiccCard = getUiccCardUsingSubId(request.subId);
                     if (uiccCard == null) {
                         loge("iccTransmitApduLogicalChannel: No UICC");
                         request.result = new IccIoResult(0x6F, 0, (byte[])null);
@@ -336,12 +339,15 @@ public class PhoneInterfaceManager extends ITelephony.Stub {
                 case EVENT_TRANSMIT_APDU_LOGICAL_CHANNEL_DONE:
                     ar = (AsyncResult) msg.obj;
                     request = (MainThreadRequest) ar.userObj;
+                    request.result = ar.result;
                     if (ar.exception == null && ar.result != null) {
-                        request.result = ar.result;
+                        if (DBG) log("EVENT_TRANSMIT_APDU_LOGICAL_CHANNEL_DONE successful");
                     } else {
-                        request.result = new IccIoResult(0x6F, 0, (byte[])null);
                         if (ar.result == null) {
-                            loge("iccTransmitApduLogicalChannel: Empty response");
+                            loge("iccTransmitApduLogicalChannel: Empty response received."
+                                    + "Setting result: sw1 = 0x6F and sw2 = 0");
+                            // If the request fails with an empty payload.
+                            request.result = new IccIoResult(0x6F, 0, (byte[])null);
                         } else if (ar.exception instanceof CommandException) {
                             loge("iccTransmitApduLogicalChannel: CommandException: " +
                                     ar.exception);
@@ -357,6 +363,7 @@ public class PhoneInterfaceManager extends ITelephony.Stub {
                 case CMD_TRANSMIT_APDU_BASIC_CHANNEL:
                     request = (MainThreadRequest) msg.obj;
                     iccArgument = (IccAPDUArgument) request.argument;
+                    uiccCard = getUiccCardUsingSubId(request.subId);
                     if (uiccCard == null) {
                         loge("iccTransmitApduBasicChannel: No UICC");
                         request.result = new IccIoResult(0x6F, 0, (byte[])null);
@@ -375,12 +382,14 @@ public class PhoneInterfaceManager extends ITelephony.Stub {
                 case EVENT_TRANSMIT_APDU_BASIC_CHANNEL_DONE:
                     ar = (AsyncResult) msg.obj;
                     request = (MainThreadRequest) ar.userObj;
+                    request.result = ar.result;
                     if (ar.exception == null && ar.result != null) {
-                        request.result = ar.result;
+                        if (DBG) log("EVENT_TRANSMIT_APDU_BASIC_CHANNEL_DONE successful");
                     } else {
-                        request.result = new IccIoResult(0x6F, 0, (byte[])null);
                         if (ar.result == null) {
-                            loge("iccTransmitApduBasicChannel: Empty response");
+                            loge("iccTransmitApduBasicChannel: Empty response received."
+                            + "Setting result: sw1 = 0x6F and sw2 = 0");
+                            request.result = new IccIoResult(0x6F, 0, (byte[])null);
                         } else if (ar.exception instanceof CommandException) {
                             loge("iccTransmitApduBasicChannel: CommandException: " +
                                     ar.exception);
@@ -396,6 +405,7 @@ public class PhoneInterfaceManager extends ITelephony.Stub {
                 case CMD_EXCHANGE_SIM_IO:
                     request = (MainThreadRequest) msg.obj;
                     iccArgument = (IccAPDUArgument) request.argument;
+                    uiccCard = getUiccCardUsingSubId(request.subId);
                     if (uiccCard == null) {
                         loge("iccExchangeSimIO: No UICC");
                         request.result = new IccIoResult(0x6F, 0, (byte[])null);
@@ -414,10 +424,20 @@ public class PhoneInterfaceManager extends ITelephony.Stub {
                 case EVENT_EXCHANGE_SIM_IO_DONE:
                     ar = (AsyncResult) msg.obj;
                     request = (MainThreadRequest) ar.userObj;
+                    request.result = ar.result;
                     if (ar.exception == null && ar.result != null) {
-                        request.result = ar.result;
+                        if (DBG) log("EVENT_EXCHANGE_SIM_IO_DONE successful");
                     } else {
-                        request.result = new IccIoResult(0x6f, 0, (byte[])null);
+                        if (ar.result == null) {
+                            loge("ccExchangeSimIO: Empty Response recieved."
+                            + "Setting result: sw1 = 0x6F and sw2 = 0");
+                            request.result = new IccIoResult(0x6F, 0, (byte[])null);
+                        } else if (ar.exception instanceof CommandException) {
+                            loge("iccTransmitApduBasicChannel: CommandException: " +
+                                    ar.exception);
+                        } else {
+                            loge("iccTransmitApduBasicChannel: Unknown exception");
+                        }
                     }
                     synchronized (request) {
                         request.notifyAll();
@@ -461,6 +481,7 @@ public class PhoneInterfaceManager extends ITelephony.Stub {
 
                 case CMD_OPEN_CHANNEL:
                     request = (MainThreadRequest) msg.obj;
+                    uiccCard = getUiccCardUsingSubId(request.subId);
                     if (uiccCard == null) {
                         loge("iccOpenLogicalChannel: No UICC");
                         request.result = new IccIoResult(0x6F, 0, (byte[])null);
@@ -518,6 +539,7 @@ public class PhoneInterfaceManager extends ITelephony.Stub {
 
                 case CMD_CLOSE_CHANNEL:
                     request = (MainThreadRequest) msg.obj;
+                    uiccCard = getUiccCardUsingSubId(request.subId);
                     if (uiccCard == null) {
                         loge("iccCloseLogicalChannel: No UICC");
                         request.result = new IccIoResult(0x6F, 0, (byte[])null);
@@ -747,6 +769,42 @@ public class PhoneInterfaceManager extends ITelephony.Stub {
                     }
                     break;
 
+                case CMD_SIM_GET_ATR:
+                    request = (MainThreadRequest) msg.obj;
+                    uiccCard = getUiccCardUsingSubId(request.subId);
+                    if (uiccCard == null) {
+                        loge("getAtr: No UICC");
+                        request.result = "";
+                         synchronized (request) {
+                            request.notifyAll();
+                        }
+                    } else {
+                        onCompleted = obtainMessage(EVENT_SIM_GET_ATR_DONE, request);
+                        uiccCard.getAtr(onCompleted);
+                    }
+                    break;
+
+                case EVENT_SIM_GET_ATR_DONE:
+                    ar = (AsyncResult) msg.obj;
+                    request = (MainThreadRequest) ar.userObj;
+                    if (ar.exception == null) {
+                        request.result = ar.result;
+                    } else {
+                        request.result = "";
+                        if (ar.result == null) {
+                            loge("ccExchangeSimIO: Empty Response");
+                        } else if (ar.exception instanceof CommandException) {
+                            loge("iccTransmitApduBasicChannel: CommandException: " +
+                                    ar.exception);
+                        } else {
+                            loge("iccTransmitApduBasicChannel: Unknown exception");
+                        }
+                    }
+                    synchronized (request) {
+                        request.notifyAll();
+                    }
+                    break;
+
                 default:
                     Log.w(LOG_TAG, "MainThreadHandler: unexpected message code: " + msg.what);
                     break;
@@ -872,6 +930,12 @@ public class PhoneInterfaceManager extends ITelephony.Stub {
     private Phone getPhone(int subId) {
         return PhoneFactory.getPhone(mSubscriptionController.getPhoneId(subId));
     }
+
+    private UiccCard getUiccCardUsingSubId(int subId) {
+        Phone phone = getPhone(subId);
+        return UiccController.getInstance().getUiccCard(phone.getPhoneId());
+    }
+
     //
     // Implementation of the ITelephony interface.
     //
@@ -1597,7 +1661,7 @@ public class PhoneInterfaceManager extends ITelephony.Stub {
      *
      * @throws SecurityException if the caller does not have the required permission/privilege
      */
-    private void enforceModifyPermissionOrCarrierPrivilege() {
+    private void enforceModifyPermissionOrCarrierPrivilege(Phone phone) {
         int permission = mApp.checkCallingOrSelfPermission(
                 android.Manifest.permission.MODIFY_PHONE_STATE);
         if (permission == PackageManager.PERMISSION_GRANTED) {
@@ -1605,12 +1669,17 @@ public class PhoneInterfaceManager extends ITelephony.Stub {
         }
 
         log("No modify permission, check carrier privilege next.");
-        if (getCarrierPrivilegeStatus() != TelephonyManager.CARRIER_PRIVILEGE_STATUS_HAS_ACCESS) {
+        if (getCarrierPrivilegeStatus(phone) !=
+                TelephonyManager.CARRIER_PRIVILEGE_STATUS_HAS_ACCESS) {
             loge("No Carrier Privilege.");
             throw new SecurityException("No modify permission or carrier privilege.");
         }
     }
 
+    private void enforceModifyPermissionOrCarrierPrivilege() {
+        enforceModifyPermissionOrCarrierPrivilege(mPhone);
+    }
+
     /**
      * Make sure the caller has carrier privilege.
      *
@@ -1969,24 +2038,34 @@ public class PhoneInterfaceManager extends ITelephony.Stub {
 
     @Override
     public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID) {
-        enforceModifyPermissionOrCarrierPrivilege();
+        return iccOpenLogicalChannelUsingSubId(getDefaultSubscription(), AID);
+    }
+
+    @Override
+    public IccOpenLogicalChannelResponse iccOpenLogicalChannelUsingSubId(int subId, String AID) {
+        enforceModifyPermissionOrCarrierPrivilege(getPhone(subId));
 
         if (DBG) log("iccOpenLogicalChannel: " + AID);
         IccOpenLogicalChannelResponse response = (IccOpenLogicalChannelResponse)sendRequest(
-            CMD_OPEN_CHANNEL, AID);
+            CMD_OPEN_CHANNEL, AID, subId);
         if (DBG) log("iccOpenLogicalChannel: " + response);
         return response;
     }
 
     @Override
     public boolean iccCloseLogicalChannel(int channel) {
-        enforceModifyPermissionOrCarrierPrivilege();
+        return iccCloseLogicalChannelUsingSubId(getDefaultSubscription(), channel);
+    }
+
+    @Override
+    public boolean iccCloseLogicalChannelUsingSubId(int subId, int channel) {
+        enforceModifyPermissionOrCarrierPrivilege(getPhone(subId));
 
         if (DBG) log("iccCloseLogicalChannel: " + channel);
         if (channel < 0) {
           return false;
         }
-        Boolean success = (Boolean)sendRequest(CMD_CLOSE_CHANNEL, channel);
+        Boolean success = (Boolean)sendRequest(CMD_CLOSE_CHANNEL, channel, subId);
         if (DBG) log("iccCloseLogicalChannel: " + success);
         return success;
     }
@@ -1994,7 +2073,14 @@ public class PhoneInterfaceManager extends ITelephony.Stub {
     @Override
     public String iccTransmitApduLogicalChannel(int channel, int cla,
             int command, int p1, int p2, int p3, String data) {
-        enforceModifyPermissionOrCarrierPrivilege();
+        return iccTransmitApduLogicalChannelUsingSubId(getDefaultSubscription(), channel,
+                cla, command, p1, p2, p3, data);
+    }
+
+    @Override
+    public String iccTransmitApduLogicalChannelUsingSubId(int subId, int channel, int cla,
+            int command, int p1, int p2, int p3, String data) {
+        enforceModifyPermissionOrCarrierPrivilege(getPhone(subId));
 
         if (DBG) {
             log("iccTransmitApduLogicalChannel: chnl=" + channel + " cla=" + cla +
@@ -2007,7 +2093,7 @@ public class PhoneInterfaceManager extends ITelephony.Stub {
         }
 
         IccIoResult response = (IccIoResult)sendRequest(CMD_TRANSMIT_APDU_LOGICAL_CHANNEL,
-                new IccAPDUArgument(channel, cla, command, p1, p2, p3, data));
+                new IccAPDUArgument(channel, cla, command, p1, p2, p3, data), subId);
         if (DBG) log("iccTransmitApduLogicalChannel: " + response);
 
         // Append the returned status code to the end of the response payload.
@@ -2022,7 +2108,14 @@ public class PhoneInterfaceManager extends ITelephony.Stub {
     @Override
     public String iccTransmitApduBasicChannel(int cla, int command, int p1, int p2,
                 int p3, String data) {
-        enforceModifyPermissionOrCarrierPrivilege();
+        return iccTransmitApduBasicChannelUsingSubId(getDefaultSubscription(), cla, command, p1,
+                p2, p3, data);
+    }
+
+    @Override
+    public String iccTransmitApduBasicChannelUsingSubId(int subId, int cla, int command, int p1,
+            int p2, int p3, String data) {
+        enforceModifyPermissionOrCarrierPrivilege(getPhone(subId));
 
         if (DBG) {
             log("iccTransmitApduBasicChannel: cla=" + cla + " cmd=" + command + " p1="
@@ -2030,7 +2123,7 @@ public class PhoneInterfaceManager extends ITelephony.Stub {
         }
 
         IccIoResult response = (IccIoResult)sendRequest(CMD_TRANSMIT_APDU_BASIC_CHANNEL,
-                new IccAPDUArgument(0, cla, command, p1, p2, p3, data));
+                new IccAPDUArgument(0, cla, command, p1, p2, p3, data), subId);
         if (DBG) log("iccTransmitApduBasicChannel: " + response);
 
         // Append the returned status code to the end of the response payload.
@@ -2045,7 +2138,14 @@ public class PhoneInterfaceManager extends ITelephony.Stub {
     @Override
     public byte[] iccExchangeSimIO(int fileID, int command, int p1, int p2, int p3,
             String filePath) {
-        enforceModifyPermissionOrCarrierPrivilege();
+        return iccExchangeSimIOUsingSubId(getDefaultSubscription(), fileID, command, p1, p2, p3,
+                filePath);
+    }
+
+    @Override
+    public byte[] iccExchangeSimIOUsingSubId(int subId, int fileID, int command, int p1, int p2,
+            int p3, String filePath) {
+        enforceModifyPermissionOrCarrierPrivilege(getPhone(subId));
 
         if (DBG) {
             log("Exchange SIM_IO " + fileID + ":" + command + " " +
@@ -2054,7 +2154,7 @@ public class PhoneInterfaceManager extends ITelephony.Stub {
 
         IccIoResult response =
             (IccIoResult)sendRequest(CMD_EXCHANGE_SIM_IO,
-                    new IccAPDUArgument(-1, fileID, command, p1, p2, p3, filePath));
+                    new IccAPDUArgument(-1, fileID, command, p1, p2, p3, filePath), subId);
 
         if (DBG) {
           log("Exchange SIM_IO [R]" + response);
@@ -2339,15 +2439,19 @@ public class PhoneInterfaceManager extends ITelephony.Stub {
         }
     }
 
-    @Override
-    public int getCarrierPrivilegeStatus() {
-        UiccCard card = UiccController.getInstance().getUiccCard(mPhone.getPhoneId());
+    public int getCarrierPrivilegeStatus(Phone phone) {
+        UiccCard card = UiccController.getInstance().getUiccCard(phone.getPhoneId());
         if (card == null) {
             loge("getCarrierPrivilegeStatus: No UICC");
             return TelephonyManager.CARRIER_PRIVILEGE_STATUS_RULES_NOT_LOADED;
         }
         return card.getCarrierPrivilegeStatusForCurrentTransaction(
-                mPhone.getContext().getPackageManager());
+                phone.getContext().getPackageManager());
+    }
+
+    @Override
+    public int getCarrierPrivilegeStatus() {
+        return getCarrierPrivilegeStatus(mPhone);
     }
 
     @Override
@@ -2880,4 +2984,26 @@ public class PhoneInterfaceManager extends ITelephony.Stub {
     public ModemActivityInfo getModemActivityInfo() {
         return (ModemActivityInfo) sendRequest(CMD_GET_MODEM_ACTIVITY_INFO, null);
     }
+
+    public byte[] getAtr() {
+        return getAtrUsingSubId(getDefaultSubscription());
+    }
+
+    @Override
+    public byte[] getAtrUsingSubId(int subId) {
+        if (Binder.getCallingUid() != Process.NFC_UID) {
+            throw new SecurityException("Only Smartcard API may access UICC");
+        }
+        Log.d(LOG_TAG, "SIM_GET_ATR ");
+        String response = (String)sendRequest(CMD_SIM_GET_ATR, null, subId);
+        byte[] result = null;
+        if (response != null && response.length() != 0) {
+            try{
+                result = IccUtils.hexStringToBytes(response);
+            } catch(RuntimeException re) {
+                Log.e(LOG_TAG, "Invalid format of the response string");
+            }
+        }
+        return result;
+    }
 }
-- 
2.7.4


From 85632924bac29388b6791701ee2d8027921ccbeb Mon Sep 17 00:00:00 2001
From: Pawit Pornkitprasan <p.pawit@gmail.com>
Date: Fri, 20 Feb 2015 20:26:52 +0700
Subject: [PATCH 2/3] Telephony: HACK: enable WCDMA only setting

Samsung stock allows WCDMA only

Change-Id: If552c6439f7b6910422ec5549e54e68da798c82e

Signed-off-by: Dominggoes Isakh <drjisakh@gmail.com>
---
 res/values/strings.xml                           | 12 +++++++++---
 src/com/android/phone/MobileNetworkSettings.java | 15 +++++++++++++--
 2 files changed, 22 insertions(+), 5 deletions(-)

diff --git a/res/values/strings.xml b/res/values/strings.xml
index 20ba412..6d9e2a8 100644
--- a/res/values/strings.xml
+++ b/res/values/strings.xml
@@ -396,6 +396,10 @@
      <!-- Mobile network settings, summary for preferred network mode TDSCDMTA [CHAR LIMIT=100] -->
      <string name="preferred_network_mode_tdscdma_summary">Preferred network mode: TDSCDMA</string>
 
+    <string name="preferred_network_mode_wcdma_only_choice">WCDMA only</string>
+    <string name="preferred_network_mode_gsm_only_choice">GSM only</string>
+    <string name="preferred_network_mode_gsm_wcdma_preferred_choice">GSM/WCDMA preferred</string>
+
     <string-array name="preferred_network_mode_choices">
         <item>LTE / WCDMA</item>
         <item>LTE</item>
@@ -611,12 +615,14 @@
     </string-array>
 
     <string-array name="enabled_networks_except_lte_choices" translatable="false">
-        <item>@string/network_3G</item>
-        <item>@string/network_2G</item>
+        <item>@string/preferred_network_mode_wcdma_only_choice</item>
+        <item>@string/preferred_network_mode_gsm_only_choice</item>
+        <item>@string/preferred_network_mode_gsm_wcdma_preferred_choice</item>
     </string-array>
     <string-array name="enabled_networks_except_lte_values" translatable="false">
-        <item>"0"</item>
+        <item>"2"</item>
         <item>"1"</item>
+        <item>"0"</item>
     </string-array>
 
     <string-array name="enabled_networks_except_gsm_lte_choices" translatable="false">
diff --git a/src/com/android/phone/MobileNetworkSettings.java b/src/com/android/phone/MobileNetworkSettings.java
index 62c8acc..4ab15e3 100644
--- a/src/com/android/phone/MobileNetworkSettings.java
+++ b/src/com/android/phone/MobileNetworkSettings.java
@@ -872,6 +872,7 @@ public class MobileNetworkSettings extends PreferenceActivity
                 switch (buttonNetworkMode) {
                     case Phone.NT_MODE_WCDMA_PREF:
                     case Phone.NT_MODE_GSM_ONLY:
+                    case Phone.NT_MODE_WCDMA_ONLY:
                     case Phone.NT_MODE_LTE_GSM_WCDMA:
                     case Phone.NT_MODE_LTE_CDMA_EVDO_GSM_WCDMA:
                     case Phone.NT_MODE_CDMA:
@@ -1101,12 +1102,22 @@ public class MobileNetworkSettings extends PreferenceActivity
                 mButtonEnabledNetworks.setSummary(R.string.network_3G);
                 break;
             case Phone.NT_MODE_WCDMA_ONLY:
+                if (!mIsGlobalCdma) {
+                    mButtonEnabledNetworks.setValue(
+                            Integer.toString(Phone.NT_MODE_WCDMA_ONLY));
+                    mButtonEnabledNetworks.setSummary(R.string.preferred_network_mode_wcdma_only_choice);
+                } else {
+                    mButtonEnabledNetworks.setValue(
+                            Integer.toString(Phone.NT_MODE_LTE_CDMA_EVDO_GSM_WCDMA));
+                    mButtonEnabledNetworks.setSummary(R.string.network_global);
+                }
+                break;
             case Phone.NT_MODE_GSM_UMTS:
             case Phone.NT_MODE_WCDMA_PREF:
                 if (!mIsGlobalCdma) {
                     mButtonEnabledNetworks.setValue(
                             Integer.toString(Phone.NT_MODE_WCDMA_PREF));
-                    mButtonEnabledNetworks.setSummary(R.string.network_3G);
+                    mButtonEnabledNetworks.setSummary(R.string.preferred_network_mode_gsm_wcdma_preferred_choice);
                 } else {
                     mButtonEnabledNetworks.setValue(
                             Integer.toString(Phone.NT_MODE_LTE_CDMA_EVDO_GSM_WCDMA));
@@ -1117,7 +1128,7 @@ public class MobileNetworkSettings extends PreferenceActivity
                 if (!mIsGlobalCdma) {
                     mButtonEnabledNetworks.setValue(
                             Integer.toString(Phone.NT_MODE_GSM_ONLY));
-                    mButtonEnabledNetworks.setSummary(R.string.network_2G);
+                    mButtonEnabledNetworks.setSummary(R.string.preferred_network_mode_gsm_only_choice);
                 } else {
                     mButtonEnabledNetworks.setValue(
                             Integer.toString(Phone.NT_MODE_LTE_CDMA_EVDO_GSM_WCDMA));
-- 
2.7.4


From a966cde75f35248993bb265eaf3de92d2748e099 Mon Sep 17 00:00:00 2001
From: Pawit Pornkitprasan <p.pawit@gmail.com>
Date: Mon, 28 Dec 2015 19:37:32 +0700
Subject: [PATCH 3/3] On create, values need to be read from the RIL, not set

This causes problem on dual SIM phones where setting one SIM to
3G would cause the RIL to automatically change the other RIL to
2G.

In this case, when the setting saved is 3G for both SIM, whenever
the user switches tab, the tab the user switches to become 3G.
For example, when the user switches to Sim 2, Sim 2 becomes 3G.
And when the user switches back to Sim 1, Sim 1 becomes 3G. This
can be very confusing, not to mention that switching between
tabs should not cause the network mode to change.

The updateBody() call is removed to ensure that when SET is called,
the value is not immediately GET from the RIL as the RIL might not
finish updating the value yet and GET will return the old value,
resulting in the following behavior:

- User is on 2G
- User switches to 3G
- UI still displays "2G" due to updating value from RIL
- After a few seconds, UI displays "3G" because RIL update is
  finished.

Not sure what the call is for, but it's probably not used in GSM
phones. Care should be taken if this patch is to be applied to
other phones.

Signed-off-by: Dominggoes Isakh <drjisakh@gmail.com>
---
 src/com/android/phone/MobileNetworkSettings.java | 30 +++++++++++++++++++++---
 1 file changed, 27 insertions(+), 3 deletions(-)

diff --git a/src/com/android/phone/MobileNetworkSettings.java b/src/com/android/phone/MobileNetworkSettings.java
index 4ab15e3..fac5662 100644
--- a/src/com/android/phone/MobileNetworkSettings.java
+++ b/src/com/android/phone/MobileNetworkSettings.java
@@ -731,8 +731,7 @@ public class MobileNetworkSettings extends PreferenceActivity
         UpdatePreferredNetworkModeSummary(settingsNetworkMode);
         UpdateEnabledNetworksValueAndSummary(settingsNetworkMode);
         // Display preferred network type based on what modem returns b/18676277
-        mPhone.setPreferredNetworkType(settingsNetworkMode, mHandler
-                .obtainMessage(MyHandler.MESSAGE_SET_PREFERRED_NETWORK_TYPE));
+        mPhone.getPreferredNetworkType(mHandler.obtainMessage(MyHandler.MESSAGE_GET_PREFERRED_NETWORK_TYPE));
 
         /**
          * Enable/disable depending upon if there are any active subscriptions.
@@ -937,7 +936,6 @@ public class MobileNetworkSettings extends PreferenceActivity
             return true;
         }
 
-        updateBody();
         // always let the preference setting proceed.
         return true;
     }
@@ -945,6 +943,7 @@ public class MobileNetworkSettings extends PreferenceActivity
     private class MyHandler extends Handler {
 
         static final int MESSAGE_SET_PREFERRED_NETWORK_TYPE = 0;
+        static final int MESSAGE_GET_PREFERRED_NETWORK_TYPE = 1;
 
         @Override
         public void handleMessage(Message msg) {
@@ -952,6 +951,9 @@ public class MobileNetworkSettings extends PreferenceActivity
                 case MESSAGE_SET_PREFERRED_NETWORK_TYPE:
                     handleSetPreferredNetworkTypeResponse(msg);
                     break;
+                case MESSAGE_GET_PREFERRED_NETWORK_TYPE:
+                    handleGetPreferredNetworkTypeResponse(msg);
+                    break;
             }
         }
 
@@ -982,6 +984,28 @@ public class MobileNetworkSettings extends PreferenceActivity
                 updatePreferredNetworkUIFromDb();
             }
         }
+
+        private void handleGetPreferredNetworkTypeResponse(Message msg) {
+            AsyncResult ar = (AsyncResult) msg.obj;
+            final int phoneSubId = mPhone.getSubId();
+
+            if (ar.exception == null) {
+                int networkMode = ((int[]) ar.result)[0];
+
+                // Store this in setting so onPreferenceChange would trigger even if
+                // network mode from modem does not equal saved network mode
+                android.provider.Settings.Global.putInt(mPhone.getContext().getContentResolver(),
+                        android.provider.Settings.Global.PREFERRED_NETWORK_MODE + phoneSubId,
+                        networkMode );
+
+                UpdatePreferredNetworkModeSummary(networkMode);
+                UpdateEnabledNetworksValueAndSummary(networkMode);
+            } else {
+                if (DBG) {
+                    log("handleGetPreferredNetworkTypeResponse: exception in geting network mode.");
+                }
+            }
+        }
     }
 
     private void updatePreferredNetworkUIFromDb() {
-- 
2.7.4

